<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Landmark Detection with 3D Pyramid</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <style>
        body {
            font-family: roboto;
            margin: 2em;
            color: #3d3d3d;
            --mdc-theme-primary: #007f8b;
            --mdc-theme-on-primary: #f1f3f4;
        }

        h1 {
            color: #007f8b;
        }

        .videoView {
            position: relative;
            width: 100%;
            margin: 2% 0;
        }

        .output_canvas {
            /* Removed transformation to prevent mirroring */
        }

        #threejs-container {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <h1>Hand Landmark Detection with 3D Pyramid</h1>
    <input type="file" id="videoFileInput" accept="video/*">
    <div id="liveView" class="videoView">
        <div style="position: relative;">
            <video id="webcam" style="position: absolute; width: 640px; height: 480px;" autoplay playsinline></video>
            <canvas class="output_canvas" id="output_canvas" style="position: absolute; left: 0px; top: 0px;"></canvas>
            <div id="threejs-container"></div>
        </div>
    </div>
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="./node_modules/@techstark/opencv-js/dist/opencv.js"></script>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const height = 480;
        const width = 640;
        const focalLength = width * 0.6;
        const center = [width / 2, height / 2];
        const cameraMatrix = [
            focalLength, 0, center[0],
            0, focalLength, center[1],
            0, 0, 1
        ];
        const distortion = [0, 0, 0, 0];

        const demosSection = document.getElementById("liveView");

        let handLandmarker = undefined;
        let runningMode = "VIDEO";
        let videoFileInput;
        let webcamRunning = false;

        const createHandLandmarker = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks("/wasm"); 

                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `./models/hand_landmarker.task`,
                        delegate: "GPU",
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    },
                    runningMode: runningMode,
                    numHands: 2
                });
                if (!handLandmarker) {
                    throw new Error("HandLandmarker initialization failed, no instance created.");
                }
                demosSection.classList.remove("invisible");
            } catch (error) {
                console.error("Failed to initialize HandLandmarker:", error);
            }
        };
        createHandLandmarker().then(() => {
            video.addEventListener("loadeddata", () => {
                video.requestVideoFrameCallback(processVideoFrame);
            });
        });



        const video = document.getElementById("webcam");

        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");

        videoFileInput = document.getElementById("videoFileInput");

        videoFileInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            const url = URL.createObjectURL(file);
            video.src = url;
            video.play();
        });

        let lastVideoTime = -1;
        let framecount = 0;
        let results = undefined;

        // Three.js setup
        const threeJsContainer = document.getElementById('threejs-container');
        const scene = new THREE.Scene();
        const aspect = width / height;
        const frustumSize = 1;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(width, height); // Match video dimensions

        threeJsContainer.appendChild(renderer.domElement);

        const geometry = new THREE.CylinderGeometry(0, 0.05, 0.15, 4);
        const material = new THREE.MeshBasicMaterial({ color: 0x0000FF });
        const pyramid = new THREE.Mesh(geometry, material);

        const edges = new THREE.EdgesGeometry(geometry);
        const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFFFF });
        const edgesMesh = new THREE.LineSegments(edges, edgesMaterial);

        pyramid.add(edgesMesh);
        scene.add(pyramid);

        const material_tvec = new THREE.MeshBasicMaterial({ color: 0xf00000 });
        const pyramid_tvec = new THREE.Mesh(geometry, material_tvec);

        const edges_tvec = new THREE.EdgesGeometry(geometry);
        const edgesMesh_tvec = new THREE.LineSegments(edges_tvec, edgesMaterial);

        pyramid_tvec.add(edgesMesh_tvec);

        scene.add(pyramid_tvec);

        camera.position.z = 1;

        function animate() {
            video.requestVideoFrameCallback(animate);
            renderer.render(scene, camera);
        }
        animate();

        function processVideoFrame() {
            if (!handLandmarker) {
                // Если handLandmarker еще не инициализирован, просто пропускаем кадр
                video.requestVideoFrameCallback(processVideoFrame);
                return;
            }

            canvasElement.style.width = width + "px";
            canvasElement.style.height = height + "px";
            canvasElement.width = width;
            canvasElement.height = height;

            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                handLandmarker.setOptions({ runningMode: "VIDEO" });
            }

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                framecount += 1
                console.log('frame number ', framecount)
                results = handLandmarker.detectForVideo(video, startTimeMs);
            }
            canvasCtx.save();

            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.landmarks) {
                for (let i = 0; i < results.landmarks.length; i++) {
                    const landmarks = results.landmarks[i];
                    const worldLandmarks = results.worldLandmarks ? results.worldLandmarks[i] : null;

                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 });
                    drawLandmarks(canvasCtx, landmarks, { color: "#FF0000", lineWidth: 2 });

                    if (worldLandmarks) {
                        updatepyramidPosition(landmarks, worldLandmarks);
                    }
                }
            }

            canvasCtx.restore();

            if (!video.paused && !video.ended) {
                video.requestVideoFrameCallback(processVideoFrame);
            }
        }

        function updatepyramidPosition(landmarks, worldlandmarks) {
            pyramid.position.set(0, 0, 0);
            pyramid_tvec.position.set(0.2, 0, 0);

            const quaternion = calculateFingerRotationpyramid(worldlandmarks, 'INDEX');
            pyramid.setRotationFromQuaternion(quaternion);

            const imagePoints = landmarks.map(
                (l) => new THREE.Vector3(l.x * width, l.y * height, 0)
            );

            const quaternion_tvec = calculateFingerRotationpyramid(transformWorldPointsUsingPnP(cameraMatrix, distortion, worldlandmarks, imagePoints));
            pyramid_tvec.setRotationFromQuaternion(quaternion_tvec);


        }

        function transformWorldPointsUsingPnP(cameraMatrix, distCoeffs, worldPoints, imagePoints) {
            const objectPoints = worldPoints.map((p) => [p.x, p.y, p.z]);
            const imagePointsCv = imagePoints.map((p) => [p.x, p.y]);

            const objectPointsMat = cv.matFromArray(objectPoints.length, 1, cv.CV_32FC3, objectPoints.flat());
            const imagePointsMat = cv.matFromArray(imagePointsCv.length, 1, cv.CV_32FC2, imagePointsCv.flat());
            const cameraMatrixCv = cv.matFromArray(3, 3, cv.CV_64FC1, cameraMatrix);
            const distCoeffsCv = cv.matFromArray(distCoeffs.length, 1, cv.CV_64FC1, distCoeffs);

            const rvec = new cv.Mat();
            const tvec = new cv.Mat();

            const solvePnPMethod = cv.SOLVEPNP_EPNP;

            cv.solvePnP(
                objectPointsMat,
                imagePointsMat,
                cameraMatrixCv,
                distCoeffsCv,
                rvec,
                tvec,
                false,
                solvePnPMethod
            );

            const rotMat = new cv.Mat();
            cv.Rodrigues(rvec, rotMat);

            const CV_64F = cv.CV_64F;
            const transformMat = cv.Mat.eye(4, 4, CV_64F);
            rotMat.copyTo(transformMat.rowRange(0, 3).colRange(0, 3));
            tvec.copyTo(transformMat.rowRange(0, 3).col(3));

            const finalTransform = new THREE.Matrix4().fromArray(transformMat.data64F);

            const transformedWorldPoints = worldPoints.map((point) => {
                const vector = new THREE.Vector4(point.x, point.y, point.z, 1).applyMatrix4(finalTransform);

                if (vector.w !== 0) {
                    vector.divideScalar(vector.w);
                }

                return new THREE.Vector3(vector.x, vector.y, vector.z);
            });

            objectPointsMat.delete();
            imagePointsMat.delete();
            cameraMatrixCv.delete();
            distCoeffsCv.delete();
            rvec.delete();
            tvec.delete();
            rotMat.delete();
            transformMat.delete();

            return transformedWorldPoints;
        }

        function calculateFingerRotationpyramid(points, finger_name = 'INDEX') {
            let idx_mcp, idx_pip, idx_mcp1, idx_mcp2;

            switch (finger_name) {
                case 'INDEX':
                    idx_mcp = 5;
                    idx_pip = 6;
                    idx_mcp1 = 5;
                    idx_mcp2 = 13;
                    break;
                case 'MIDDLE':
                    idx_mcp = 9;
                    idx_pip = 10;
                    idx_mcp1 = 5;
                    idx_mcp2 = 13;
                    break;
                case 'RING':
                    idx_mcp = 13;
                    idx_pip = 14;
                    idx_mcp1 = 5;
                    idx_mcp2 = 13;
                    break;
                case 'PINKY':
                    idx_mcp = 17;
                    idx_pip = 18;
                    idx_mcp1 = 5;
                    idx_mcp2 = 13;
                    break;
                default:
                    idx_mcp = 2;
                    idx_pip = 3;
                    idx_mcp1 = 5;
                    idx_mcp2 = 9;
                    break;
            }

            let point_mcp1 = new THREE.Vector3(points[idx_mcp1].x, points[idx_mcp1].y, points[idx_mcp1].z);
            let point_mcp2 = new THREE.Vector3(points[idx_mcp2].x, points[idx_mcp2].y, points[idx_mcp2].z);
            let point_pip = new THREE.Vector3(points[idx_pip].x, points[idx_pip].y, points[idx_pip].z);
            let point_mcp = new THREE.Vector3(points[idx_mcp].x, points[idx_mcp].y, points[idx_mcp].z);


            const base_vector = point_mcp2.clone().sub(point_mcp1).normalize();
            const finger_vector = point_pip.clone().sub(point_mcp).normalize();

            const zAxis = finger_vector.clone();

            let xAxis = new THREE.Vector3().crossVectors(finger_vector, base_vector).normalize();

            const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize();

            const rotation_matrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);

            const quaternion = new THREE.Quaternion().setFromRotationMatrix(rotation_matrix);


            //trying to fetch the opengl coordinates, still not correct

            /* const rotationY = new THREE.Quaternion();
            rotationY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

            const rotationX = new THREE.Quaternion();
            rotationX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI);

            let transformedQuaternion = quaternion.clone();
            transformedQuaternion.multiply(rotationY).multiply(rotationX);
            transformedQuaternion.x *= -1 */
            return quaternion

        } 
    </script>
</body>

</html>