<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Landmark Detection with 3D Cone</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <style>
        body {
            font-family: roboto;
            margin: 2em;
            color: #3d3d3d;
            --mdc-theme-primary: #007f8b;
            --mdc-theme-on-primary: #f1f3f4;
        }

        h1 {
            color: #007f8b;
        }

        .videoView,
        .detectOnClick {
            position: relative;
            float: left;
            width: 48%;
            margin: 2% 1%;
            cursor: pointer;
        }

        .output_canvas {
            /* Removed transformation to prevent mirroring */
        }

        #threejs-container {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <h1>Hand Landmark Detection with 3D Cone</h1>
    <div id="liveView" class="videoView">
        <button id="webcamButton" class="mdc-button mdc-button--raised">
            <span class="mdc-button__ripple"></span>
            <span class="mdc-button__label">ENABLE WEBCAM</span>
        </button>
        <div style="position: relative;">
            <video id="webcam" style="position: absolute; width: 1280px; height: 768px;" autoplay playsinline></video>
            <canvas class="output_canvas" id="output_canvas" style="position: absolute; left: 0px; top: 0px;"></canvas>
            <div id="threejs-container"></div>
        </div>
    </div>
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const demosSection = document.getElementById("liveView");

        let handLandmarker = undefined;
        let runningMode = "IMAGE";
        let enableWebcamButton;
        let webcamRunning = false;

        const createHandLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numHands: 2
            });
            demosSection.classList.remove("invisible");
        };
        createHandLandmarker();

        const video = document.getElementById("webcam");

        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");

        const hasGetUserMedia = () => !!navigator.mediaDevices?.getUserMedia;

        if (hasGetUserMedia()) {
            enableWebcamButton = document.getElementById("webcamButton");
            enableWebcamButton.addEventListener("click", enableCam);
        } else {
            console.warn("getUserMedia() is not supported by your browser");
        }

        function enableCam(event) {
            if (!handLandmarker) {
                console.log("Wait! objectDetector not loaded yet.");
                return;
            }

            if (webcamRunning === true) {
                webcamRunning = false;
                enableWebcamButton.innerText = "ENABLE PREDICTIONS";
            } else {
                webcamRunning = true;
                enableWebcamButton.innerText = "DISABLE PREDICTIONS";
            }

            const constraints = {
                video: true
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            });
        }

        let lastVideoTime = -1;
        let results = undefined;

        // Three.js setup
        const threeJsContainer = document.getElementById('threejs-container');
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 1;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(1280, 768); // Match video dimensions

        renderer.setSize(window.innerWidth, window.innerHeight);
        threeJsContainer.appendChild(renderer.domElement);

        const geometry = new THREE.ConeGeometry(0.05, 0.15, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0x808080 });
        const cone = new THREE.Mesh(geometry, material);
        scene.add(cone);

        camera.position.z = 1;

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        async function predictWebcam() {
            canvasElement.style.width = 1280 + "px";
            canvasElement.style.height = 768 + "px";
            console.log(canvasElement.style.width, ' ', canvasElement.style.height)
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;

            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await handLandmarker.setOptions({ runningMode: "VIDEO" });
            }

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                results = handLandmarker.detectForVideo(video, startTimeMs);
            }
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.landmarks) {
                for (const landmarks of results.landmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 });
                    drawLandmarks(canvasCtx, landmarks, { color: "#FF0000", lineWidth: 2 });
                    updateConePosition(landmarks);  // Update cone position based on the index finger tip
                    console.log(landmarks)
                }
            }
            canvasCtx.restore();

            if (webcamRunning === true) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        function updateConePosition(landmarks) {
            const tip = landmarks[8];
            const base = landmarks[0]; // Use wrist as the base for orientation

            // Convert landmark positions from normalized space to Three.js space
            const x = (tip.x - 0.5) * frustumSize * aspect;
            const y = -(tip.y - 0.5) * frustumSize;
            const z = (tip.z - 0.5) * frustumSize; // Adjusted to positive depth values

            /* const x = tip.x * 1280
            const y = tip.y * 768
            const z = tip.z * 1280 */

            cone.position.set(x, y, z);

            // Calculate rotation
            const dx = base.x - tip.x;
            const dy = base.y - tip.y;
            const dz = base.z - tip.z;

            const angleX = Math.atan2(dy, dz);
            const angleY = Math.atan2(dx, dz);

            // Rotate the cone around the x-axis by 90 degrees and adjust for other rotations
            cone.rotation.set(angleX + Math.PI / 2, angleY, 0);
        }
    </script>
</body>
</html>
